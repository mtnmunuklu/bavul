package fetchers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/mtnmunuklu/bavul/vulnerability/models"
)

type NVDFetcher struct {
	NVDKey string
}

func NewNVDFetcher(apiKey string) *NVDFetcher {
	return &NVDFetcher{
		NVDKey: apiKey,
	}
}

type NvdCve struct {
	Cve struct {
		ID               string `json:"id"`
		PublishedDate    string `json:"published"`
		LastModifiedDate string `json:"lastModified"`
		VulnStatus       string `json:"vulnStatus"`
		Description      []struct {
			Lang  string `json:"lang"`
			Value string `json:"value"`
		} `json:"descriptions"`
		Metrics struct {
			BaseMetricV31 []struct {
				CvssData            CvssData `json:"cvssData"`
				ExploitabilityScore float64  `json:"exploitabilityScore"`
				ImpactScore         float64  `json:"impactScore"`
			} `json:"cvssMetricV31"`
			BaseMetricV3 []struct {
				CvssData            CvssData `json:"cvssData"`
				ExploitabilityScore float64  `json:"exploitabilityScore"`
				ImpactScore         float64  `json:"impactScore"`
			} `json:"cvssMetricV30"`
			BaseMetricV2 []struct {
				Source                  string   `json:"source"`
				Type                    string   `json:"type"`
				CvssData                CvssData `json:"cvssData"`
				Severity                string   `json:"severity"`
				ExploitabilityScore     float64  `json:"exploitabilityScore"`
				ImpactScore             float64  `json:"impactScore"`
				ObtainAllPrivilege      bool     `json:"obtainAllPrivilege"`
				ObtainUserPrivilege     bool     `json:"obtainUserPrivilege"`
				ObtainOtherPrivilege    bool     `json:"obtainOtherPrivilege"`
				UserInteractionRequired bool     `json:"userInteractionRequired"`
			} `json:"cvssMetricV2"`
		} `json:"metrics"`
		References []struct {
			URL       string `json:"url"`
			Refsource string `json:"source"`
		} `json:"references"`
		Configurations []struct {
			Nodes []struct {
				Operator string `json:"operator"`
				Negate   bool   `json:"negate"`
				CpeMatch []struct {
					Criteria              string `json:"criteria"`
					MatchCriteriaID       string `json:"matchCriteriaId"`
					Vulnerable            bool   `json:"vulnerable"`
					VersionStartIncluding string `json:"versionStartIncluding"`
					VersionStartExcluding string `json:"versionStartExcluding"`
					VersionEndIncluding   string `json:"versionEndIncluding"`
					VersionEndExcluding   string `json:"versionEndExcluding"`
				} `json:"cpeMatch"`
			} `json:"nodes"`
		} `json:"configurations"`
	} `json:"cve"`
}

type NvdData struct {
	StartIndex        int      `json:"startIndex"`
	TotalResultsCount int      `json:"totalResults"`
	CVEItems          []NvdCve `json:"vulnerabilities"`
	DataFormat        string   `json:"format"`
	DataVersion       string   `json:"version"`
}

type CvssData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AccessVector          string  `json:"accessVector"`
	AccessComplexity      string  `json:"accessComplexity"`
	Authentication        string  `json:"authentication"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
}

// FetchCVEData fetches CVE data from NVD API and returns the result.
func (fetcher *NVDFetcher) FetchCVEData() (NvdData, error) {
	const (
		resultsPerPage = 1
		retryTimes     = 3
	)

	// You can use fetcher.NVDKey here to use your API key.
	nvdDelay := time.Second * 6
	if fetcher.NVDKey != "" {
		nvdDelay = time.Second
	}

	var results NvdData
	index := 0
	totalResults := 1

	// Retry fetching data for each CVE item
	for index < totalResults {
		var response *http.Response
		var currentBatch NvdData

		// Retry for each CVE item
		for retries := 0; retries <= retryTimes; retries++ {
			newURL := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0/?resultsPerPage=%d&startIndex=%d", resultsPerPage, index)
			client := &http.Client{
				Transport: &http.Transport{
					MaxIdleConns:        10,
					IdleConnTimeout:     30 * time.Second,
					DisableKeepAlives:   true,
					TLSHandshakeTimeout: 10 * time.Second,
				},
				Timeout: time.Second * 10,
			}

			request, err := http.NewRequest("GET", newURL, nil)
			if err != nil {
				return results, fmt.Errorf("failed to create request: %v", err)
			}

			if fetcher.NVDKey != "" {
				request.Header.Set("apiKey", fetcher.NVDKey)
			}

			response, err = client.Do(request)
			if err != nil {
				time.Sleep(nvdDelay) // Wait before retrying
				continue             // Retry on error
			}

			defer response.Body.Close()

			err = json.NewDecoder(response.Body).Decode(&currentBatch)
			if err != nil {
				time.Sleep(nvdDelay) // Wait before retrying
				continue             // Retry on error
			}

			if index == 0 {
				results = currentBatch
				totalResults = currentBatch.TotalResultsCount
			} else {
				results.CVEItems = append(results.CVEItems, currentBatch.CVEItems...)
			}

			index += resultsPerPage
			break // Break the retry loop if successful
		}

		if response != nil && response.StatusCode != http.StatusOK {
			// Retry for the current CVE item
			time.Sleep(nvdDelay) // Wait before retrying
			continue
		}

		// Break the loop if all retries fail
		if response == nil || response.StatusCode != http.StatusOK {
			return results, fmt.Errorf("failed to fetch data for CVE item after %d retries", retryTimes)
		}
	}

	return results, nil
}

// ConvertNvdDataToCVE converts NvdData to an array of CVE structs.
func (fetcher *NVDFetcher) ConvertNvdDataToCVE(nvdData NvdData) []models.CVE {
	cves := []models.CVE{}

	for _, item := range nvdData.CVEItems {
		cve := models.CVE{
			CveId:       item.Cve.ID,
			Description: item.Cve.Description[0].Value,
			Severity:    getSeverity(item),
			Product:     getProductFromConfigurations(item),
			Vendor:      getVendorFromConfigurations(item),
			Links:       getReferenceLinks(item),
			Published:   parseTime(item.Cve.PublishedDate),
			Modified:    parseTime(item.Cve.LastModifiedDate),
		}

		cves = append(cves, cve)
	}

	return cves
}

func getSeverity(cve NvdCve) string {
	if len(cve.Cve.Metrics.BaseMetricV31) > 0 {
		return cve.Cve.Metrics.BaseMetricV31[0].CvssData.VectorString
	} else if len(cve.Cve.Metrics.BaseMetricV3) > 0 {
		return cve.Cve.Metrics.BaseMetricV3[0].CvssData.VectorString
	} else if len(cve.Cve.Metrics.BaseMetricV2) > 0 {
		return cve.Cve.Metrics.BaseMetricV2[0].Severity
	}
	return ""
}

func getProductFromConfigurations(cve NvdCve) string {
	configurations := cve.Cve.Configurations
	for _, node := range configurations[0].Nodes {
		for _, cpeMatch := range node.CpeMatch {
			if cpeMatch.Vulnerable {
				parts := strings.Split(cpeMatch.Criteria, ":")
				if len(parts) >= 5 {
					return parts[4]
				}
			}
		}
	}
	return ""
}

func getVendorFromConfigurations(cve NvdCve) string {
	configurations := cve.Cve.Configurations
	for _, node := range configurations[0].Nodes {
		for _, cpeMatch := range node.CpeMatch {
			if cpeMatch.Vulnerable {
				parts := strings.Split(cpeMatch.Criteria, ":")
				if len(parts) >= 4 {
					return parts[3]
				}
			}
		}
	}
	return ""
}

func getReferenceLinks(cve NvdCve) []string {
	references := cve.Cve.References
	links := []string{}
	for _, ref := range references {
		links = append(links, ref.URL)
	}
	return links
}

func parseTime(dateStr string) time.Time {
	t, err := time.Parse(time.RFC3339, dateStr)
	if err != nil {
		return time.Time{}
	}
	return t
}
