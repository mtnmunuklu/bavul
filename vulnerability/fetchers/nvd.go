package fetchers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/mtnmunuklu/bavul/vulnerability/models"
	"github.com/mtnmunuklu/bavul/vulnerability/util"
	"gopkg.in/mgo.v2/bson"
)

type NVDFetcher struct {
	NVDKey    string
	NVDClient NVDClient
}

func NewNVDFetcher(apiKey string) *NVDFetcher {
	return &NVDFetcher{
		NVDKey: apiKey,
	}
}

func (fetcher *NVDFetcher) SetNVDClient(client NVDClient) {
	fetcher.NVDClient = client
}

type NVDClient interface {
	FetchCVEData() (NVDData, error)
	ConvertNvdDataToCVE(nvdData NVDData) []models.CVE
}

type NVDCve struct {
	Cve struct {
		ID               string `json:"id"`
		SourceIdentifier string `json:"sourceIdentifier"`
		PublishedDate    string `json:"published"`
		LastModifiedDate string `json:"lastModified"`
		VulnStatus       string `json:"vulnStatus"`
		Description      []struct {
			Lang  string `json:"lang"`
			Value string `json:"value"`
		} `json:"descriptions"`
		Metrics struct {
			BaseMetricV31 []struct {
				CvssData            CvssData `json:"cvssData"`
				ExploitabilityScore float64  `json:"exploitabilityScore"`
				ImpactScore         float64  `json:"impactScore"`
			} `json:"cvssMetricV31"`
			BaseMetricV3 []struct {
				CvssData            CvssData `json:"cvssData"`
				ExploitabilityScore float64  `json:"exploitabilityScore"`
				ImpactScore         float64  `json:"impactScore"`
			} `json:"cvssMetricV30"`
			BaseMetricV2 []struct {
				Source                  string   `json:"source"`
				Type                    string   `json:"type"`
				CvssData                CvssData `json:"cvssData"`
				BaseSeverity            string   `json:"baseSeverity"`
				ExploitabilityScore     float64  `json:"exploitabilityScore"`
				ImpactScore             float64  `json:"impactScore"`
				AcInsufInfo             bool     `json:"acInsufInfo"`
				ObtainAllPrivilege      bool     `json:"obtainAllPrivilege"`
				ObtainUserPrivilege     bool     `json:"obtainUserPrivilege"`
				ObtainOtherPrivilege    bool     `json:"obtainOtherPrivilege"`
				UserInteractionRequired bool     `json:"userInteractionRequired"`
			} `json:"cvssMetricV2"`
		} `json:"metrics"`
		References []struct {
			URL       string `json:"url"`
			Refsource string `json:"source"`
		} `json:"references"`
		Configurations []struct {
			Nodes []struct {
				Operator string `json:"operator"`
				Negate   bool   `json:"negate"`
				CpeMatch []struct {
					Criteria              string `json:"criteria"`
					MatchCriteriaID       string `json:"matchCriteriaId"`
					Vulnerable            bool   `json:"vulnerable"`
					VersionStartIncluding string `json:"versionStartIncluding"`
					VersionStartExcluding string `json:"versionStartExcluding"`
					VersionEndIncluding   string `json:"versionEndIncluding"`
					VersionEndExcluding   string `json:"versionEndExcluding"`
				} `json:"cpeMatch"`
			} `json:"nodes"`
		} `json:"configurations"`
	} `json:"cve"`
}

type NVDData struct {
	StartIndex        int      `json:"startIndex"`
	TotalResultsCount int      `json:"totalResults"`
	CVEItems          []NVDCve `json:"vulnerabilities"`
	DataFormat        string   `json:"format"`
	DataVersion       string   `json:"version"`
}

type CvssData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AccessVector          string  `json:"accessVector"`
	AccessComplexity      string  `json:"accessComplexity"`
	Authentication        string  `json:"authentication"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
}

// FetchCVEData fetches CVE data from NVD API and returns the result.
func (fetcher *NVDFetcher) FetchCVEData() (NVDData, error) {

	if fetcher.NVDClient != nil {
		return fetcher.NVDClient.FetchCVEData()
	}

	const (
		resultsPerPage = 1
		retryTimes     = 3
	)

	// You can use fetcher.NVDKey here to use your API key.
	nvdDelay := time.Second * 6
	if fetcher.NVDKey != "" {
		nvdDelay = time.Second
	}

	var results NVDData
	index := 0
	totalResults := 1

	// Retry fetching data for each CVE item
	for index < totalResults {
		var response *http.Response
		var currentBatch NVDData

		// Retry for each CVE item
		for retries := 0; retries <= retryTimes; retries++ {
			newURL := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0/?resultsPerPage=%d&startIndex=%d", resultsPerPage, index)
			client := &http.Client{
				Transport: &http.Transport{
					MaxIdleConns:        10,
					IdleConnTimeout:     30 * time.Second,
					DisableKeepAlives:   true,
					TLSHandshakeTimeout: 10 * time.Second,
				},
				Timeout: time.Second * 10,
			}

			request, err := http.NewRequest("GET", newURL, nil)
			if err != nil {
				return results, fmt.Errorf("failed to create request: %v", err)
			}

			if fetcher.NVDKey != "" {
				request.Header.Set("apiKey", fetcher.NVDKey)
			}

			response, err = client.Do(request)
			if err != nil {
				time.Sleep(nvdDelay) // Wait before retrying
				continue             // Retry on error
			}

			defer response.Body.Close()

			err = json.NewDecoder(response.Body).Decode(&currentBatch)
			if err != nil {
				time.Sleep(nvdDelay) // Wait before retrying
				continue             // Retry on error
			}

			if index == 0 {
				results = currentBatch
				totalResults = currentBatch.TotalResultsCount
			} else {
				results.CVEItems = append(results.CVEItems, currentBatch.CVEItems...)
			}

			index += resultsPerPage
			break // Break the retry loop if successful
		}

		if response != nil && response.StatusCode != http.StatusOK {
			// Retry for the current CVE item
			time.Sleep(nvdDelay) // Wait before retrying
			continue
		}

		// Break the loop if all retries fail
		if response == nil || response.StatusCode != http.StatusOK {
			return results, fmt.Errorf("failed to fetch data for CVE item after %d retries", retryTimes)
		}
	}

	return results, nil
}

// ConvertNvdDataToCVE converts NvdData to an array of CVE structs.
func (fetcher *NVDFetcher) ConvertNvdDataToCVE(nvdData NVDData) []models.CVE {

	if fetcher.NVDClient != nil {
		return fetcher.NVDClient.ConvertNvdDataToCVE(nvdData)
	}

	cves := []models.CVE{}

	for _, item := range nvdData.CVEItems {
		cve := models.CVE{
			Id: bson.NewObjectId(),
		}

		// Check if there is Cve ID
		if cveID := item.Cve.ID; cveID != "" {
			cve.CveId = cveID
		}

		// Check if there is at least one description
		if len(item.Cve.Description) > 0 {
			cve.Description = item.Cve.Description[0].Value
		}

		// Check if there is severity information
		if severity := getSeverity(item); severity != "" {
			cve.Severity = severity
		}

		// Check if there is product information
		if product := getProductFromConfigurations(item); product != "" {
			cve.Product = product
		}

		// Check if there is vendor information
		if vendor := getVendorFromConfigurations(item); vendor != "" {
			cve.Vendor = vendor
		}

		// Check if there are reference links
		if links := getReferenceLinks(item); len(links) > 0 {
			cve.Links = links
		}

		// Check if there is published date information
		if published := util.ParseTime(item.Cve.PublishedDate); !published.IsZero() {
			cve.Published = published
		}

		// Check if there is modified date information
		if modified := util.ParseTime(item.Cve.LastModifiedDate); !modified.IsZero() {
			cve.Modified = modified
		}

		cves = append(cves, cve)
	}

	return cves
}

func getSeverity(cve NVDCve) string {
	if cve.Cve.Metrics.BaseMetricV31 != nil && len(cve.Cve.Metrics.BaseMetricV31) > 0 && cve.Cve.Metrics.BaseMetricV31[0].CvssData != (CvssData{}) {
		baseScore := cve.Cve.Metrics.BaseMetricV31[0].CvssData.BaseScore
		return cvssBaseScoreToString(baseScore)
	} else if cve.Cve.Metrics.BaseMetricV3 != nil && len(cve.Cve.Metrics.BaseMetricV3) > 0 && cve.Cve.Metrics.BaseMetricV3[0].CvssData != (CvssData{}) {
		baseScore := cve.Cve.Metrics.BaseMetricV3[0].CvssData.BaseScore
		return cvssBaseScoreToString(baseScore)
	} else if cve.Cve.Metrics.BaseMetricV2 != nil && len(cve.Cve.Metrics.BaseMetricV2) > 0 && cve.Cve.Metrics.BaseMetricV2[0].CvssData != (CvssData{}) {
		baseScore := cve.Cve.Metrics.BaseMetricV2[0].CvssData.BaseScore
		return cvssBaseScoreToString(baseScore)
	}
	return ""
}

func cvssBaseScoreToString(baseScore float64) string {
	switch {
	case baseScore == 0:
		return "None"
	case baseScore >= 0.1 && baseScore <= 3.9:
		return "Low"
	case baseScore >= 4.0 && baseScore <= 6.9:
		return "Medium"
	case baseScore >= 7.0 && baseScore <= 8.9:
		return "High"
	case baseScore >= 9.0 && baseScore <= 10.0:
		return "Critical"
	default:
		return "Unknown"
	}
}

func getProductFromConfigurations(cve NVDCve) string {
	if cve.Cve.Configurations != nil && len(cve.Cve.Configurations) > 0 {
		configurations := cve.Cve.Configurations[0].Nodes
		for _, node := range configurations {
			for _, cpeMatch := range node.CpeMatch {
				if cpeMatch.Vulnerable {
					parts := strings.Split(cpeMatch.Criteria, ":")
					if len(parts) >= 5 {
						return parts[4]
					}
				}
			}
		}
	}
	return ""
}

func getVendorFromConfigurations(cve NVDCve) string {
	if cve.Cve.Configurations != nil && len(cve.Cve.Configurations) > 0 {
		configurations := cve.Cve.Configurations[0].Nodes
		for _, node := range configurations {
			for _, cpeMatch := range node.CpeMatch {
				if cpeMatch.Vulnerable {
					parts := strings.Split(cpeMatch.Criteria, ":")
					if len(parts) >= 4 {
						return parts[3]
					}
				}
			}
		}
	}
	return ""
}

func getReferenceLinks(cve NVDCve) []string {
	if cve.Cve.References != nil {
		references := cve.Cve.References
		links := []string{}
		for _, ref := range references {
			links = append(links, ref.URL)
		}
		return links
	}
	return nil
}
